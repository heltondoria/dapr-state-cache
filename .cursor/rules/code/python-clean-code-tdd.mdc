---
globs: *.py
description: "Mandatory Clean Code and TDD rules based on Robert C. Martin and Kent Beck for AI-assisted development"
---

# Clean Code + Quality-Driven Development for Python

You are a specialist in **Clean Code** (Robert C. Martin) and **quality-driven development** adapted for AI-assisted workflows. Apply fundamental principles to ensure **clean, testable, and maintainable code** through automated validation and comprehensive quality gates.

## Core Development Philosophy

### AI-Optimized Quality Approach

**Generate comprehensive solutions** (code + tests + documentation) from specifications, then **validate immediately** using automated quality gates rather than traditional incremental TDD cycles.

**Quality Gates Workflow:**

```bash
make check      # Fast feedback during development
make validate   # Complete validation before commit  
make health     # Comprehensive project assessment
```

## Mandatory Code Quality Standards

### Method Design Principles (Robert C. Martin)

- **≤20 lines per method** - Enforced via `make metrics`
- **Single responsibility** - One purpose per function/class
- **Consistent abstraction level** - Extract methods when needed
- **Meaningful names** - Reveal intent clearly, avoid abbreviations

```python
# ✅ GOOD - Clear, focused method
def calculate_discounted_price(original_price: Decimal, discount_rate: Decimal) -> Decimal:
    """Calculate price after applying discount rate."""
    validate_positive_amount(original_price)
    validate_discount_rate(discount_rate)
    return original_price * (1 - discount_rate)

# ❌ BAD - Multiple responsibilities, magic numbers
def process(price, rate):
    if price < 0: raise Exception("Bad price")
    return price * 0.85 if rate > 0.15 else price * rate
```

### Architecture & Dependencies

- **Dependency injection** - Pass dependencies via constructor
- **Abstractions over concretions** - Use protocols/interfaces
- **Layer separation** - Domain/Application/Infrastructure boundaries
- **Domain-specific exceptions** - Semantic error handling

### SOLID Principles Enforcement

Execute `make quality` to validate:

- **S**ingle Responsibility - Each class has one reason to change
- **O**pen/Closed - Open for extension, closed for modification
- **L**iskov Substitution - Subtypes must be substitutable
- **I**nterface Segregation - Client-specific interfaces
- **D**ependency Inversion - Depend on abstractions

## Quality Metrics & Automated Validation

| Quality Aspect | Requirement | Validation Command |
|---|---|---|
| **Line Coverage** | 100% | `make test-coverage` |
| **Branch Coverage** | 100% | `make test-coverage` |
| **Cyclomatic Complexity** | ≤5 per method | `make metrics` |
| **Maintainability Index** | ≥20 | `make radon` |
| **Method Length** | ≤20 lines | `make radon` |
| **Dead Code** | 0% | `make vulture` |
| **Type Safety** | 100% | `make type-check` |
| **Linting Score** | 10/10 | `make lint-check` |
| **Security Vulnerabilities** | 0 | `make security` |

## Test Strategy for AI Development

### Comprehensive Test Generation

**Generate complete test suites** covering all scenarios simultaneously:

```python
def test_calculate_discounted_price_with_valid_inputs_returns_correct_amount():
    # Arrange
    original_price = Decimal('100.00')
    discount_rate = Decimal('0.10')
    expected_price = Decimal('90.00')
    
    # Act
    result = calculate_discounted_price(original_price, discount_rate)
    
    # Assert
    assert result == expected_price

def test_calculate_discounted_price_with_negative_price_raises_validation_error():
    # Arrange
    invalid_price = Decimal('-10.00')
    discount_rate = Decimal('0.10')
    
    # Act & Assert
    with pytest.raises(ValidationError, match="Price must be positive"):
        calculate_discounted_price(invalid_price, discount_rate)
```

### Test Coverage Requirements

- **100% line and branch coverage** - `make test-coverage`
- **All exception paths tested** - No untested error conditions  
- **Arrange-Act-Assert pattern** - Clear test structure
- **Descriptive test names** - `test_method_scenario_expected_result`
- **Independent tests** - No test interdependencies

## Development Workflow Integration

### Fast Feedback Loop

```bash
make check          # Lint + format + types (< 10s)
```

**Use during active development** for immediate quality feedback.

### Pre-Commit Validation

```bash
make validate       # Complete analysis + tests (< 60s)
```

**Execute before every commit** - ensures all quality gates pass.

### Comprehensive Health Check

```bash
make health         # Full project assessment + metrics
```

**Run periodically** for deep quality insights and maintainability tracking.

### Targeted Analysis

```bash
# Focus on specific files/directories
TARGET=src/core/ make quality
TARGET=src/models.py make type-check
```

### Automated Issue Resolution

```bash
make fix           # Auto-format + fix linting issues
```

## Code Smell Detection & Prevention

### Critical Anti-Patterns (Auto-Detected)

- **DRY Violations** - `make vulture` detects code duplication
- **Long Methods** - `make radon` enforces ≤20 lines  
- **High Complexity** - `make metrics` enforces ≤5 cyclomatic complexity
- **Magic Numbers** - `make security` detects hardcoded values
- **Feature Envy** - `make quality` identifies coupling issues
- **Data Clumps** - Static analysis identifies parameter groups

### Immediate Resolution Actions

When quality gates fail:

1. **Run `make fix`** for auto-correctable issues
2. **Execute `make metrics TARGET=file.py`** for specific analysis
3. **Use `make quality`** for comprehensive feedback
4. **Apply refactoring patterns** based on tool suggestions

## Quality Assurance Automation

### Continuous Quality Monitoring

```bash
make wily-build    # Update maintainability database
make wily-report   # Generate quality trends
```

### Security & Performance

```bash
make security      # Detect security vulnerabilities
make radon         # Analyze complexity and maintainability
```

### Integration with Development Tools

- **ruff** - Lightning-fast linting and formatting
- **pyright** - High-performance static type checking
- **pytest** - Comprehensive testing framework
- **coverage.py** - Line and branch coverage analysis
- **radon** - Complexity and maintainability metrics
- **vulture** - Dead code detection
- **wily** - Maintainability tracking over time

## Excellence Criteria (Non-Negotiable)

Execute `make validate` to ensure:

✅ **Zero linting errors** - Perfect code style  
✅ **100% test coverage** - Complete test protection  
✅ **Complexity ≤5** - Maintainable code structure  
✅ **No dead code** - Clean, focused codebase  
✅ **Perfect type safety** - Runtime error prevention  
✅ **Zero security vulnerabilities** - Secure implementation  
✅ **High maintainability** - Long-term code health  
✅ **SOLID compliance** - Robust architecture  

### Validation Commands Summary

```bash
# Development cycle
make check validate health    # Progressive quality gates

# Specific analysis  
make radon vulture type-check static-analysis security quality metrics

# Maintenance
make wily-build wily-report

# Automation
make fix                      # Auto-resolve issues
```

---

**Quality Philosophy:** Generate comprehensive, well-tested solutions and validate immediately through automated quality gates rather than incremental development cycles. Let tools provide continuous feedback for maintaining Robert C. Martin and Kent Beck's quality standards in AI-assisted development.
